<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org" xmlns:layout="http://www.ultraq.net.nz/thymeleaf/layout"
	layout:decorate="~{Common/LayoutBase}">

<th:block layout:fragment="title">Memo</th:block>

<th:block layout:fragment="header">
	<th:block th:replace="~{Fragments/Header :: Header_Search(
		leftTitle=~{Fragments/Icons :: favicon},
		title='Fragment', 
		rightTitle=~{Fragments/Icons :: fragment_write}
	) }"></th:block>
</th:block>

<th:block layout:fragment="content">

	<!-- ë¦¬ìŠ¤íŠ¸ -->
	<div id="fragmentList" class="space-y-3"></div>

	<!-- ìƒíƒœ/ë¡œë”© -->
	<div id="stateBox" class="hidden mt-3 mx-2 rounded-2xl border p-3 text-sm"></div>
	<div id="pageSentinel" class="h-1"></div>

	<!-- fragment card template -->
	<template id="tplFragmentCard">
		<article class="rounded-2xl border border-slate-200 bg-white shadow-sm overflow-hidden">
			<!-- top meta -->
			<div class="px-3 pt-3">
				<div class="flex items-center justify-between gap-2">
					<!-- topic badge -->
					<div class="flex items-center gap-2 min-w-0">
						<div class="topic-pill inline-flex items-center gap-1.5
						              rounded-full px-2.5 py-1 text-sm font-semibold
						              bg-slate-100 max-w-full min-w-0">
							<span class="topic-emoji shrink-0">ğŸ§©</span>
							<span class="topic-name truncate max-w-[12rem]">Topic</span>
						</div>
					</div>

					<!-- user + date -->
					<div class="flex items-center gap-2 shrink-0">
						<img class="user-img w-6 h-6 rounded-full border border-slate-200 object-cover" alt="U" />
						<div class="text-sm font-medium text-slate-700 user-name max-w-[120px] truncate">User</div>
						<div class="text-xs text-slate-400 tabular-nums reg-date">2026-01-24 05:09</div>
					</div>
				</div>

				<!-- content -->
				<div class="mt-2 text-base text-slate-900 leading-relaxed content"></div>

				<!-- hashtags -->
				<div class="mt-2 flex flex-wrap gap-1.5 hashtag-box"></div>
			</div>

			<!-- bottom bar: LEFT emotions / RIGHT actions -->
			<div class="mt-3 border-t border-slate-100 px-3 py-2">
				<div class="flex items-center justify-between gap-2">
					<!-- emotions (LEFT) -->
					<div class="emotion-row flex flex-wrap items-center gap-2 min-w-0">
						<!-- emotion buttons injected -->
					</div>

					<!-- actions (RIGHT) -->
					<div class="action-row flex items-center gap-2 shrink-0">
						<button type="button"
							class="btn-share p-1.5 rounded-full border border-slate-200 text-slate-600 hover:bg-slate-100"
							aria-label="share">
							<span class="icon-share w-5 h-5"></span>
						</button>

						<button type="button"
							class="btn-scrap p-1.5 rounded-full border border-slate-200 text-slate-600 hover:bg-slate-100"
							aria-label="scrap">
							<span class="icon-scrap w-5 h-5"></span>
						</button>

						<button type="button"
							class="btn-comment p-1.5 rounded-full border border-slate-200 text-slate-600 hover:bg-slate-100"
							aria-label="comment">
							<span class="icon-comment w-5 h-5"></span>
						</button>
					</div>
				</div>

				<!-- ëŒ“ê¸€ ì˜ì—­ (í† ê¸€ë¡œ ì—´ë¦¼/ë‹«í˜) -->
				<div class="commentWrap hidden border-t border-slate-100 px-3 py-3">
					<!-- [2] ëŒ“ê¸€ ì‘ì„± -->
					<div class="commentComposer flex items-start gap-2">
						<!-- [2.1] ë¡œê·¸ì¸ ì‚¬ìš©ì í”„ë¡œí•„ -->
						<img class="meImg w-8 h-8 rounded-full border border-slate-200 object-cover" alt="me" />

						<!-- [2.2] ì…ë ¥(ì—¬ëŸ¬ ì¤„ ìë™ í™•ì¥) -->
						<textarea class="commentInput flex-1 resize-none rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm leading-relaxed
				             focus:outline-none focus:ring-2 focus:ring-slate-200" rows="1" placeholder="ëŒ“ê¸€ì„ ì…ë ¥í•´ ì£¼ì„¸ìš”."></textarea>

						<!-- [2.3] ì €ì¥ ë²„íŠ¼ -->
						<button type="button" class="btnSaveComment shrink-0 inline-flex items-center justify-center w-10 h-10 rounded-xl
				             border border-slate-200 bg-white hover:bg-slate-50 active:bg-slate-100" aria-label="save comment">
							<span class="iconSaveComment"></span>
						</button>
					</div>

					<!-- [3] ëŒ“ê¸€ ë¦¬ìŠ¤íŠ¸ -->
					<div class="commentList mt-3 space-y-2"></div>

					<!-- ëŒ“ê¸€ ë¡œë”© ìƒíƒœ -->
					<div class="commentState hidden mt-2 text-xs text-slate-400"></div>

					<!-- ëŒ“ê¸€ ë”ë³´ê¸° ë²„íŠ¼ (í˜ì´ì§€ë„¤ì´ì…˜) -->
					<button type="button" class="btnMoreComments hidden mt-3 w-full flex items-center justify-center gap-2
				           rounded-xl border border-slate-200 bg-white py-2 text-sm text-slate-700
				           hover:bg-slate-50 active:bg-slate-100">
						<span class="iconMoreComments"></span>
						<span>ëŒ“ê¸€ ë”ë³´ê¸°</span>
					</button>

				</div>

			</div>

			<!-- hidden fields -->
			<div class="hidden fragment-uid"></div>
			<div class="hidden emoji-set-type"></div>
		</article>
	</template>

	<template id="tplCommentItem">
		<div class="rounded-xl border border-slate-200 bg-white px-3 py-2">
			<div class="flex items-start gap-2">
				<!-- [3.1] í”„ë¡œí•„ -->
				<img class="cUserImg w-7 h-7 rounded-full border border-slate-200 object-cover" alt="u" />

				<div class="flex-1 min-w-0">
					<!-- ìƒë‹¨ ë¼ì¸: [3.5]ë‹‰ë„¤ì„ + [3.2]ë‚ ì§œ + [3.3][3.4]ì´ëª¨ì…˜ í•© -->
					<div class="flex items-center gap-2">
						<div class="cNick text-sm font-semibold text-slate-800 truncate">ë‹‰ë„¤ì„</div>
						<div class="cDate text-[11px] text-slate-400 whitespace-nowrap">2026-01-01 13:11</div>

						<button type="button"
							class="cEmoSummary ml-auto inline-flex items-center gap-1 rounded-full border border-slate-200 bg-slate-50 px-2 py-1 text-xs text-slate-700 hover:bg-slate-100">
							<span class="cEmoIcon"></span>
							<span class="cEmoSum tabular-nums">0</span>
						</button>
					</div>

					<!-- [3.6] ë‚´ìš© -->
					<div class="cContent mt-1 text-sm text-slate-800 whitespace-pre-wrap break-words"></div>

					<!-- [4.1] ì´ëª¨ì…˜ íŒ¨ë„(í† ê¸€) -->
					<div class="cEmoPanel hidden mt-2 flex flex-wrap gap-2"></div>
				</div>
			</div>
		</div>
	</template>

</th:block>

<th:block layout:fragment="footer">
	<th:block th:replace="~{Fragments/Footer :: BasicFooter}"></th:block>
</th:block>

<th:block layout:fragment="script">
	<script th:inline="javascript">

		// ë¡œê·¸ì¸ ì‚¬ìš©ì (ë¹„ë¡œê·¸ì¸: null)
		const LOGIN_USER = /*[[${user}]]*/ null;
		const IS_LOGIN = !!(LOGIN_USER && LOGIN_USER.uid);

		function toastLoginRequired() {
			showToast?.("ë¡œê·¸ì¸ í•„ìš”", "ë¡œê·¸ì¸ í›„ ì´ìš©í•´ ì£¼ì„¸ìš”.", ToastType?.INFO ?? "info", 1800);
		}

		// fragmentë³„ ëŒ“ê¸€ í˜ì´ì§€ ìƒíƒœ ìœ ì§€
		const commentStateMap = new Map();
		// uid -> { page:1, loading:false, done:false }

		const fragmentCardMap = new Map();


		(() => {
			const $ = (id) => document.getElementById(id);
			const elList = $("fragmentList");
			const elState = $("stateBox");
			const tpl = $("tplFragmentCard");

			let pageNo = 1;
			let loading = false;
			let done = false;

			function showState(type, text) {
				elState.classList.remove("hidden");
				elState.textContent = text;

				elState.classList.remove(
					"bg-red-50", "border-red-200", "text-red-700",
					"bg-slate-50", "border-slate-200", "text-slate-700"
				);
				if (type === "err") elState.classList.add("bg-red-50", "border-red-200", "text-red-700");
				else elState.classList.add("bg-slate-50", "border-slate-200", "text-slate-700");
			}
			function hideState() {
				elState.classList.add("hidden");
				elState.textContent = "";
			}

			function safeText(v, fallback = "") {
				if (v === null || v === undefined) return fallback;
				const s = String(v).trim();
				return s ? s : fallback;
			}

			// --- inline SVGs (ìš”ì²­í•œ ê²ƒ ê·¸ëŒ€ë¡œ) ---
			function svgShare() {
				return `
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="20" height="20" fill="none">
  <circle cx="48" cy="16" r="8" fill="#4B5563"/>
  <circle cx="16" cy="32" r="8" fill="#4B5563"/>
  <circle cx="48" cy="48" r="8" fill="#4B5563"/>
  <line x1="22.7" y1="28.6" x2="41.3" y2="19.4" stroke="#4B5563" stroke-width="4" stroke-linecap="round"/>
  <line x1="22.7" y1="35.4" x2="41.3" y2="44.6" stroke="#4B5563" stroke-width="4" stroke-linecap="round"/>
</svg>`;
			}
			function svgScrap(on) {
				if (on) return `
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" width="20" height="20">
  <path d="M20 5 H80 V95 L50 70 L20 95 Z" fill="#374151" stroke="#111827" stroke-width="4" stroke-linejoin="round"/>
  <line x1="34" y1="30" x2="66" y2="30" stroke="#E5E7EB" stroke-width="3" stroke-linecap="round"/>
  <line x1="34" y1="45" x2="66" y2="45" stroke="#E5E7EB" stroke-width="3" stroke-linecap="round"/>
  <line x1="34" y1="60" x2="56" y2="60" stroke="#E5E7EB" stroke-width="3" stroke-linecap="round"/>
</svg>`;
				return `
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" width="20" height="20">
  <path d="M20 5 H80 V95 L50 70 L20 95 Z" fill="none" stroke="#4B5563" stroke-width="4" stroke-linejoin="round"/>
  <line x1="34" y1="30" x2="66" y2="30" stroke="#4B5563" stroke-width="3" stroke-linecap="round"/>
  <line x1="34" y1="45" x2="66" y2="45" stroke="#4B5563" stroke-width="3" stroke-linecap="round"/>
  <line x1="34" y1="60" x2="56" y2="60" stroke="#4B5563" stroke-width="3" stroke-linecap="round"/>
</svg>`;
			}
			function svgComment() {
				return `
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 120 100" width="20" height="20">
  <path d="M20 10 H100 Q110 10 110 20 V65 Q110 75 100 75 H65 L55 90 L50 75 H20 Q10 75 10 65 V20 Q10 10 20 10 Z"
    fill="#F9FAFB" stroke="#4B5563" stroke-width="4" stroke-linejoin="round"/>
  <line x1="25" y1="25" x2="25" y2="65" stroke="#4B5563" stroke-width="4" stroke-linecap="round"/>
  <line x1="40" y1="30" x2="90" y2="30" stroke="#4B5563" stroke-width="3" stroke-linecap="round"/>
  <line x1="40" y1="45" x2="90" y2="45" stroke="#4B5563" stroke-width="3" stroke-linecap="round"/>
  <line x1="40" y1="60" x2="75" y2="60" stroke="#4B5563" stroke-width="3" stroke-linecap="round"/>
</svg>`;
			}

			function svgSaveComment() {
				return `
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="20" height="20" fill="none">
  <path d="M5 6 Q5 4 7 4 H17 Q19 4 19 6 V13 Q19 15 17 15 H10 L7 18 V15 H7 Q5 15 5 13 Z"
        stroke="currentColor" stroke-width="1.8" stroke-linejoin="round" stroke-linecap="round"/>
  <path d="M9.2 10.5 L11.2 12.5 L14.8 9"
        stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>`;
			}

			function svgCommentEmotionIcon() {
				return `
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="18" height="18" fill="none">
  <path d="M5 6 Q5 4 7 4 H17 Q19 4 19 6 V13 Q19 15 17 15 H10 L7 18 V15 H7 Q5 15 5 13 Z"
        stroke="currentColor" stroke-width="1.8" stroke-linejoin="round" stroke-linecap="round"/>
  <circle cx="12" cy="10" r="3.2" stroke="currentColor" stroke-width="1.2"/>
  <circle cx="11" cy="9.5" r="0.35" fill="currentColor"/>
  <circle cx="13" cy="9.5" r="0.35" fill="currentColor"/>
  <path d="M10.9 10.9 Q12 11.6 13.1 10.9"
        stroke="currentColor" stroke-width="0.6" stroke-linecap="round" stroke-linejoin="round"/>
</svg>`;
			}

			function svgMoreComments() {
				return `
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="18" height="18" fill="none">
  <path d="M6 9l6 6 6-6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>`;
			}

			/* textarea ìë™ í™•ì¥ */
			function autoGrowTextarea(ta) {
				if (!ta) return;
				const grow = () => {
					ta.style.height = 'auto';
					ta.style.height = Math.min(160, ta.scrollHeight) + 'px'; // ë„ˆë¬´ ì»¤ì§€ì§€ ì•Šê²Œ ìƒí•œ
				};
				ta.addEventListener('input', grow);
				grow();
			}

			/* ëŒ“ê¸€ í† ê¸€([1]) + ë¡œë”© */
			async function toggleCommentsForCard(node, item) {

				const wrap = node.querySelector('.commentWrap');
				const listEl = node.querySelector('.commentList');
				const stateEl = node.querySelector('.commentState');

				if (!wrap || !listEl) return;

				const opened = !wrap.classList.contains('hidden');

				if (opened) {
					// ë‹¤ì‹œ ëˆ„ë¥´ë©´ ìˆ¨ê¹€
					wrap.classList.add('hidden');
					return;
				}
				
				// ì—´ê¸°: í˜„ì¬ fragmentê°€ í™”ë©´ ë§¨ ìœ„ë¡œ
				node.scrollIntoView({block: 'start', behavior: 'smooth'});

				wrap.classList.remove('hidden');
				// âœ… ë¹„ë¡œê·¸ì¸: ëŒ“ê¸€ ì‘ì„± ì˜ì—­ ìˆ¨ê¹€(ëª©ë¡ë§Œ ë³´ê¸°)
				const composer = node.querySelector('.commentComposer');
				if (!IS_LOGIN) {
				  composer?.classList.add('hidden');
				} else {
				  composer?.classList.remove('hidden');
				}

				// âœ… ëŒ“ê¸€ ë”ë³´ê¸° ë²„íŠ¼ ì„¸íŒ…(ì—´ë¦´ ë•Œ 1íšŒ ë°”ì¸ë”© + ì´ˆê¸° ìˆ¨ê¹€)
				const moreBtn = node.querySelector(".btnMoreComments");
				const moreIcon = node.querySelector(".iconMoreComments");

				if (moreBtn && moreIcon) {
					moreIcon.innerHTML = svgMoreComments();

					// ì²˜ìŒ ì—´ ë•ŒëŠ” ë¡œë”© ì „ì´ë¯€ë¡œ ìˆ¨ê¹€(ë°ì´í„°ê°€ ìˆìœ¼ë©´ loadNextCommentsì—ì„œ ë³´ì—¬ì¤Œ)
					moreBtn.classList.add("hidden");

					// ì¤‘ë³µ ë°”ì¸ë”© ë°©ì§€
					if (!moreBtn.dataset.bound) {
						moreBtn.dataset.bound = "1";
						moreBtn.addEventListener("click", async (e) => {
							e.stopPropagation();
							await loadNextComments(node, item);
						});
					}
				}


				// ì—´ê¸° ì§í›„ textarea ë†’ì´ ì¬ê³„ì‚° (hiddenì—ì„œ ê³„ì‚°ëœ ê°’ ë³´ì •)
				const ta = node.querySelector('.commentInput');
				if (ta) {
					requestAnimationFrame(() => {
						ta.style.height = 'auto';
						ta.style.height = Math.min(160, ta.scrollHeight) + 'px';
					});
				}

				// ìµœì´ˆ ìƒíƒœ ì´ˆê¸°í™”
				commentStateMap.set(item.uid, {page: 1, loading: false, done: false});
				node.querySelector('.commentList').innerHTML = '';

				await loadNextComments(node, item);
			}

			/* ëŒ“ê¸€ ì¡°íšŒ([3]) + í˜ì´ì§•(í”„ë˜ê·¸ë¨¼íŠ¸ë³„ page ìœ ì§€)  */
			async function loadNextComments(node, item) {
				const fuid = item.uid;
				const st = commentStateMap.get(fuid);
				if (!st || st.loading || st.done) return;

				const listEl = node.querySelector(".commentList");
				const stateEl = node.querySelector(".commentState");
				const moreBtn = node.querySelector(".btnMoreComments");

				st.loading = true;

				// ë¡œë”© UI
				if (stateEl) {
					stateEl.classList.remove("hidden");
					stateEl.textContent = "ëŒ“ê¸€ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘â€¦";
				}
				if (moreBtn) {
					moreBtn.disabled = true;
					moreBtn.classList.add("opacity-60");
				}

				try {
					const url = /*[[@{/Fragment/Comments.json}]]*/ "/Fragment/Comments.json";

					// âœ… í•„ìš”í•˜ë©´ emojiSetTypeë„ ê°™ì´ ë³´ëƒ„(ì´ë¯¸ ìš”ì²­í•˜ì‹  ë°©ì‹)
					const res = await apiGetWithParam(url, {
						uid: fuid,
						pageNo: st.page,
						emojiSetType: item?.topic?.emojiSetType
					});

					if (!res || res.code !== "0") {
						if (stateEl) stateEl.textContent = res?.message || "ëŒ“ê¸€ ë¡œë”© ì‹¤íŒ¨";
						return;
					}

					const arr = Array.isArray(res.data) ? res.data : [];

					// âœ… ë” ì´ìƒ ì—†ìŒ â†’ done ì²˜ë¦¬ + ë”ë³´ê¸° ìˆ¨ê¹€
					if (arr.length === 0) {
						st.done = true;
						if (stateEl) stateEl.classList.add("hidden");
						if (moreBtn) moreBtn.classList.add("hidden");
						return;
					}

					// append
					arr.forEach((c) => {
						listEl.appendChild(renderCommentItem(c, item.topic?.emojiSetType));
					});

					// ë‹¤ìŒ í˜ì´ì§€
					st.page += 1;

					// âœ… ì•„ì§ ë” ìˆì„ ìˆ˜ ìˆìŒ â†’ ë”ë³´ê¸° í‘œì‹œ
					if (moreBtn) moreBtn.classList.remove("hidden");
					if (stateEl) stateEl.classList.add("hidden");

				} catch (e) {
					if (stateEl) stateEl.textContent = "ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜";
				} finally {
					st.loading = false;

					if (moreBtn) {
						moreBtn.disabled = false;
						moreBtn.classList.remove("opacity-60");
					}
				}
			}

			/* ëŒ“ê¸€ ë¬´í•œ ìŠ¤í¬ë¡¤(ëŒ“ê¸€ ì˜ì—­ì´ í¼ì³ì§„ ê²½ìš°ë§Œ) */
			function loadMoreCommentsIfAnyOpened() {
				const openedWraps = document.querySelectorAll(".commentWrap:not(.hidden)");

				openedWraps.forEach((wrap) => {
					const card = wrap.closest("article");
					if (!card) return;

					const fuid = card.dataset.fragmentUid;
					if (!fuid) return;

					const ref = fragmentCardMap.get(fuid);
					if (!ref) return;

					// âœ… commentWrap í•˜ë‹¨ì´ í™”ë©´ ì•„ë˜ìª½ì— ê°€ê¹Œì›Œì§€ë©´ ë‹¤ìŒ í˜ì´ì§€ ë¡œë“œ
					const rect = wrap.getBoundingClientRect();
					const threshold = 180; // ì—¬ìœ ê°’
					const nearBottom = rect.bottom < (window.innerHeight + threshold);

					if (nearBottom) {
						loadNextComments(ref.node, ref.item); // st.loading/done ì²´í¬ëŠ” ë‚´ë¶€ì—ì„œ í•¨
					}
				});
			}


			function applyTopicColor(pill, color) {
				if (!color) return;
				if (/^#[0-9a-fA-F]{6}$/.test(color)) {
					pill.style.background = color;
					pill.style.border = "1px solid rgba(148,163,184,0.35)";
				}
			}

			function renderHashtags(box, list) {
				box.innerHTML = "";
				if (!list || list.length === 0) return;
				list.forEach((t) => {
					const tag = document.createElement("span");
					tag.className = "inline-flex items-center rounded-full border border-slate-200 bg-slate-50 px-2 py-0.5 text-xs text-slate-700";
					tag.textContent = "#" + String(t);
					box.appendChild(tag);
				});
			}

			function renderEmotions(row, item) {
				row.innerHTML = "";
				const list = item.emotionList || [];

				list.forEach((e) => {
					const code = String(e.emotion || "");
					const count = Number(e.count || 0);

					const btn = document.createElement("button");
					btn.type = "button";

					// âœ… ìˆ«ì ì—†ëŠ” ë¯¸ë‹ˆë©€ ë²„íŠ¼
					btn.className =
						"emotion-btn relative inline-flex items-center justify-center " +
						"w-8 h-8 rounded-full border border-slate-200 bg-white " +
						"hover:bg-slate-50 active:bg-slate-100";

					btn.dataset.emotion = code;
					btn.dataset.count = String(count);

					// emojië§Œ
					btn.innerHTML = `
			      <span class="text-lg leading-none">${emotionEmoji(code)}</span>
			    `;

					// ì ‘ê·¼ì„±(íˆ´íŒ/ìˆ«ì ìˆ¨ê²¨ë„ ì˜ë¯¸ ìœ ì§€)
					btn.setAttribute("aria-label", `${code}${count > 0 ? " " + count : ""}`);

					btn.addEventListener("click", async (ev) => {
						ev.stopPropagation();
						if (!IS_LOGIN) {
							toastLoginRequired();
							return;
						}
						await clickEmotion(btn, item);
					});

					row.appendChild(btn);
				});
			}

			function bounce(el) {
				// Tailwind ì»¤ìŠ¤í…€ ì• ë‹ˆë©”ì´ì…˜ ì„¤ì • ì—†ì´ Web Animations APIë¡œ ì²˜ë¦¬
				el.animate(
					[
						{transform: "scale(1)"},
						{transform: "scale(1.14)"},
						{transform: "scale(0.96)"},
						{transform: "scale(1)"}
					],
					{duration: 220, easing: "cubic-bezier(.2,.9,.2,1)"}
				);
			}

			function showEmotionTooltip(btn, count) {
				// âœ… 0ì´ë©´ ì•„ì˜ˆ í‘œì‹œí•˜ì§€ ì•ŠìŒ
				if (!count || count <= 0) return;

				// ê°™ì€ ì¹´ë“œ(ë˜ëŠ” ê°™ì€ row) ë‚´ ê¸°ì¡´ íˆ´íŒ ì œê±°
				const root = btn.closest("article") || btn.closest(".emotion-row") || document;
				root.querySelectorAll(".emotion-tooltip").forEach(el => el.remove());

				const tip = document.createElement("div");
				tip.className =
					"emotion-tooltip absolute -top-9 left-1/2 -translate-x-1/2 " +
					"whitespace-nowrap rounded-full border border-slate-200 bg-white " +
					"px-2 py-1 text-xs text-slate-700 shadow-md pointer-events-none";

				// ë§í’ì„  ê¼¬ë¦¬
				tip.innerHTML = `
			    <div class="flex items-center gap-1">
			      <span class="font-semibold tabular-nums">${Number(count).toLocaleString()}</span>
			    </div>
			    <div class="absolute left-1/2 -bottom-1.5 -translate-x-1/2 w-2.5 h-2.5 rotate-45
			                bg-white border-r border-b border-slate-200"></div>
			  `;

				btn.appendChild(tip);

				// ë“±ì¥ ì• ë‹ˆë©”ì´ì…˜
				tip.animate(
					[
						{opacity: 0, transform: "translate(-50%, 6px) scale(0.98)"},
						{opacity: 1, transform: "translate(-50%, 0px) scale(1)"}
					],
					{duration: 140, easing: "ease-out"}
				);

				// 1.2ì´ˆ í›„ ìë™ ì œê±°
				window.setTimeout(() => {
					tip.animate(
						[
							{opacity: 1, transform: "translate(-50%, 0px) scale(1)"},
							{opacity: 0, transform: "translate(-50%, 6px) scale(0.98)"}
						],
						{duration: 120, easing: "ease-in"}
					).onfinish = () => tip.remove();
				}, 1200);
			}

			function emotionEmoji(code) {
				// í•„ìš” ì‹œ ì¶”ê°€/ìˆ˜ì •
				switch (code) {
					case "LIKE": return "ğŸ‘";
					case "EMPATHY": return "â¤ï¸";
					case "FUNNY": return "ğŸ˜‚";
					case "SURPRISE": return "ğŸ˜®";
					case "SADNESS": return "ğŸ˜¢";
					case "JOY": return "ğŸ˜Š";
					case "NORMAL": return "ğŸ˜";
					case "ANGER": return "ğŸ˜ ";
					case "AWESOME": return "ğŸ¤©";
					default: return "ğŸ™‚";
				}
			}

			async function clickEmotion(btn, item) {
				const uid = (item.uid || "").trim();
				const emotion = (btn.dataset.emotion || "").trim();
				const emojiSetType = safeText(item.topic?.emojiSetType, "");

				if (!uid || !emotion || !emojiSetType) return;

				// âœ… ì¦‰ì‹œ ì†ë§›(ë°”ìš´ìŠ¤)
				bounce(btn);

				btn.disabled = true;
				btn.classList.add("opacity-60");

				try {
					const url = /*[[@{/Fragment/EmotionFragment.json}]]*/ "/Fragment/EmotionFragment.json";
					const res = await apiPost(url, {uid, emotion, emojiSetType});

					if (!res || res.code !== "0") {
						showToast("ì˜¤ë¥˜", (res && res.message) ? res.message : "ì´ëª¨ì…˜ ì²˜ë¦¬ ì‹¤íŒ¨", ToastType.ERROR);
						return;
					}

					// âœ… ì„œë²„ê°€ emotionList ì „ì²´ë¥¼ ë‚´ë ¤ì¤Œ â†’ êµì²´
					const newList = Array.isArray(res.data) ? res.data : [];
					item.emotionList = newList;

					// í•´ë‹¹ ì¹´ë“œì˜ rowë¥¼ ë‹¤ì‹œ ë Œë”
					const row = btn.closest(".emotion-row");
					if (row) {
						renderEmotions(row, item);

						// âœ… ì—…ë°ì´íŠ¸ëœ ë²„íŠ¼ì„ ì°¾ì•„ì„œ íˆ´íŒ í‘œì‹œ(0ì´ë©´ ì•ˆ ëœ¸)
						const newBtn = row.querySelector(`button.emotion-btn[data-emotion="${CSS.escape(emotion)}"]`);
						if (newBtn) {
							const cntObj = newList.find(x => String(x.emotion) === emotion);
							const updatedCount = Number(cntObj?.count || 0);

							// ë°”ìš´ìŠ¤ëŠ” í•œ ë²ˆ ë”(ì›í•˜ë©´ ì œê±° ê°€ëŠ¥)
							bounce(newBtn);

							showEmotionTooltip(newBtn, updatedCount);
						}
					}

				} catch (e) {
					console.error(e);
					showToast("ì˜¤ë¥˜", "ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜ë¡œ ì´ëª¨ì…˜ ì²˜ë¦¬ ì‹¤íŒ¨", ToastType.ERROR);
				} finally {
					btn.disabled = false;
					btn.classList.remove("opacity-60");
				}
			}


			function bindActions(node, item) {
				const uid = node.querySelector(".fragment-uid").textContent.trim();

				// icons
				node.querySelector(".icon-share").innerHTML = svgShare();
				//node.querySelector(".icon-comment").innerHTML = svgComment();
				// âœ… ëŒ“ê¸€ í—ˆìš© ì—¬ë¶€
				const useComments = !!item?.topic?.comments;
				const btnComment = node.querySelector(".btn-comment");
				const iconComment = node.querySelector(".icon-comment");

				if (!useComments) {
					// ë²„íŠ¼ ìì²´ ìˆ¨ê¹€(ê¶Œì¥)
					btnComment?.classList.add("hidden");
				} else {
					// í‘œì‹œ + ì•„ì´ì½˜ + í´ë¦­ ë°”ì¸ë”©
					btnComment?.classList.remove("hidden");
					if (iconComment) iconComment.innerHTML = svgComment();

					btnComment?.addEventListener("click", async (e) => {
						e.stopPropagation();
						await toggleCommentsForCard(node, item);
					});
				}

				// scrap icon initial
				const iconScrap = node.querySelector(".icon-scrap");
				iconScrap.innerHTML = svgScrap(!!item.scrap);

				// share (ì¼ë‹¨ placeholder)
				node.querySelector(".btn-share").addEventListener("click", async (e) => {
					e.stopPropagation();

					const uid = node.querySelector(".fragment-uid")?.textContent?.trim();
					if (!uid) {
						showToast?.("ê³µìœ ", "ê³µìœ í•  í•­ëª©ì„ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.", ToastType?.ERROR ?? "error", 1500);
						return;
					}

					// 1) ì§€ì› ì²´í¬
					if (!navigator.share) {
						showToast?.("ê³µìœ ", "ì´ ë¸Œë¼ìš°ì €ëŠ” ê³µìœ  ê¸°ëŠ¥ì„ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.", ToastType?.INFO ?? "info", 1800);
						return;
					}

					try {
						// 2) ê³µìœ  ë°ì´í„° ì¡°íšŒ
						const url = /*[[@{/FragmentShare.json}]]*/ "/FragmentShare.json";
						const res = await apiGetWithParam(url, {uid});

						if (!res || res.code !== "0" || !res.data) {
							showToast?.("ê³µìœ ", res?.message || "ê³µìœ  ì •ë³´ë¥¼ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.", ToastType?.ERROR ?? "error", 1800);
							return;
						}

						const payload = {
							title: res.data.title ?? "",
							text: res.data.text ?? "",
							url: res.data.url ?? ""
						};

						// (ì„ íƒ) Web Share API Level 2: íŠ¹ì • íƒ€ì… ì§€ì› í™•ì¸
						// if (navigator.canShare && !navigator.canShare(payload)) { ... }

						// 3) ì‹¤ì œ ê³µìœ 
						await navigator.share(payload);

					} catch (err) {
						// ì‚¬ìš©ìê°€ ê³µìœ ì°½ì„ ë‹«ëŠ” ê²½ìš°ë„ rejectë¡œ ì˜¬ ìˆ˜ ìˆì–´ ê³¼í•˜ê²Œ ì—ëŸ¬ í† ìŠ¤íŠ¸ ë„ìš°ì§€ ì•ŠëŠ” ê²Œ UXìƒ ì¢‹ìŒ
						// í•„ìš”í•˜ë©´ err.name === 'AbortError' ë¶„ê¸° ê°€ëŠ¥
						console.error(err);
						showToast?.("ê³µìœ ", "ê³µìœ ë¥¼ ì™„ë£Œí•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.", ToastType?.INFO ?? "info", 1500);
					}
				});

				// scrap toggle
				let busy = false;
				node.querySelector(".btn-scrap").addEventListener("click", async (e) => {
					e.stopPropagation();
					if (!IS_LOGIN) {
						toastLoginRequired();
						return;
					}

					if (!uid || busy) return;

					busy = true;
					try {
						const url = /*[[@{/Fragment/Scrap.json}]]*/ "/Fragment/Scrap.json";
						const res = await apiPost(url, {uid});

						if (!res || res.code !== "0") {
							showToast("ì˜¤ë¥˜", (res && res.message) ? res.message : "ìŠ¤í¬ë© ì‹¤íŒ¨", ToastType.ERROR);
							return;
						}

						const newVal = !!res.data;
						item.scrap = newVal;
						iconScrap.innerHTML = svgScrap(newVal);

					} catch (err) {
						console.error(err);
						showToast("ì˜¤ë¥˜", "ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜ë¡œ ìŠ¤í¬ë© ì‹¤íŒ¨", ToastType.ERROR);
					} finally {
						busy = false;
					}
				});
			}

			function createCard(item) {
				const node = tpl.content.firstElementChild.cloneNode(true);

				// bind basic
				node.querySelector(".fragment-uid").textContent = safeText(item.uid, "");
				node.querySelector(".emoji-set-type").textContent = safeText(item.topic?.emojiSetType, "");

				// ìƒˆë¡œ ì¶”ê°€
				node.dataset.fragmentUid = safeText(item.uid, "");
				fragmentCardMap.set(node.dataset.fragmentUid, {node, item});

				const pill = node.querySelector(".topic-pill");
				pill.addEventListener("click", (e) => {
					e.stopPropagation();
					const topicUid = item.topic?.uid;
					location.href = `${window.contextPath}/Fragment/index.html?topicUid=${topicUid}`;
				});

				node.querySelector(".topic-emoji").textContent = safeText(item.topic?.imogi, "ğŸ§©");
				node.querySelector(".topic-name").textContent = safeText(item.topic?.name, "Topic");
				applyTopicColor(pill, safeText(item.topic?.color, ""));

				const userImg = node.querySelector(".user-img");
				const profileUrl = safeText(item.user?.profileUrl, "");
				if (profileUrl) userImg.src = profileUrl; else userImg.removeAttribute("src");
				userImg.alt = item.user?.nickname;

				const userNameEl = node.querySelector(".user-name");
				userNameEl.textContent = safeText(item.user?.nickname, "Unknown");
				userNameEl.addEventListener("click", (e) => {
					e.stopPropagation();
					const userUid = item.user?.uid;
					if (userUid) {
						// ì—¬ê¸°ì—ì„œ í”„ë¡œí•„ë¡œ ê°€ê²Œ í• ê¹Œ? ì•„ë‹ˆë©´ ì´ì‚¬ëŒì˜ ì‘ì„±ê¸€ì„ ë³´ì—¬ì¤„ê¹Œ?
						//location.href = `${window.contextPath}/User/Profile.html?uid=${userUid}`;
						location.href = `${window.contextPath}/Fragment/index.html?userUid=${userUid}`;
					}
				});
				node.querySelector(".reg-date").textContent = safeText(item.regDate, "");
				node.querySelector(".content").innerHTML = safeText(item.content, "");

				renderHashtags(node.querySelector(".hashtag-box"), item.hashtagList || []);
				// âœ… emotion ì„¤ì • ë°˜ì˜
				const emotionRow = node.querySelector(".emotion-row");
				const useEmotion = !!item?.topic?.emotion;

				if (!useEmotion) {
					// ìˆ¨ê¹€
					emotionRow?.classList.add("hidden");
				} else {
					// í‘œì‹œ + ë Œë”
					emotionRow?.classList.remove("hidden");
					renderEmotions(emotionRow, item);
				}

				bindActions(node, item);

				if (IS_LOGIN) {
					const userProfileUrl = /*[[${user?.profileUrl}]]*/ null;
					bindCommentComposer(node, item, userProfileUrl);
				}

				return node;
			}

			function sumEmotion(emotionList) {
				if (!Array.isArray(emotionList)) return 0;
				return emotionList.reduce((acc, x) => acc + (Number(x.count) || 0), 0);
			}

			function renderCommentItem(comment, emojiSetType) {
				const tpl = document.getElementById('tplCommentItem');
				const node = tpl.content.firstElementChild.cloneNode(true);

				// í”„ë¡œí•„/ë‹‰/ë‚ ì§œ/ë‚´ìš©
				const img = node.querySelector('.cUserImg');
				const nick = node.querySelector('.cNick');
				const date = node.querySelector('.cDate');
				const cont = node.querySelector('.cContent');

				const u = comment.user || {};
				if (img && u.profileUrl) img.src = u.profileUrl;
				nick.textContent = u.nickname || 'User';
				date.textContent = comment.regDate || '';
				cont.textContent = comment.content || '';

				// [3.3][3.4]
				const btnSum = node.querySelector('.cEmoSummary');
				const icon = node.querySelector('.cEmoIcon');
				const sumEl = node.querySelector('.cEmoSum');
				const panel = node.querySelector('.cEmoPanel');

				icon.innerHTML = svgCommentEmotionIcon();
				const applySum = () => {sumEl.textContent = String(sumEmotion(comment.emotionList || []));};
				applySum();

				// íŒ¨ë„ì— ì´ëª¨ì…˜ ë²„íŠ¼ ë Œë”(ì›ê¸€ê³¼ ë™ì¼í•œ ë Œë” ì „ëµ)
				const renderPanel = () => {
					panel.innerHTML = '';
					(comment.emotionList || []).forEach(e => {
						const code = String(e.emotion || '');
						const btn = document.createElement('button');
						btn.type = 'button';
						btn.className = "emotion-btn relative inline-flex items-center justify-center w-10 h-10 rounded-full border border-slate-200 bg-white hover:bg-slate-50";
						btn.dataset.emotion = code;
						btn.innerHTML = `<span class="text-lg">${emotionEmoji(code)}</span>`;

						btn.addEventListener('click', async (ev) => {
							ev.stopPropagation();
							await clickCommentEmotion(btn, comment, emojiSetType, applySum, renderPanel);
						});

						panel.appendChild(btn);
					});
				};
				renderPanel();

				// í† ê¸€
				btnSum.addEventListener('click', (e) => {
					e.stopPropagation();
					panel.classList.toggle('hidden');
				});

				return node;
			}

			async function clickCommentEmotion(btn, comment, emojiSetType, applySum, rerenderPanel) {
				const uid = (comment.uid || '').trim();
				const emotion = (btn.dataset.emotion || '').trim();
				if (!uid || !emotion) return;

				// ì›ê¸€ê³¼ ë™ì¼í•œ ì•¡ì…˜(ë°”ìš´ìŠ¤/íˆ´íŒ) ì¬ì‚¬ìš© ê°€ëŠ¥
				// bounce(btn);

				btn.disabled = true;
				btn.classList.add('opacity-60');

				try {
					const url = /*[[@{/Fragment/EmotionComment.json}]]*/ '/Fragment/EmotionComment.json';
					const res = await apiPost(url, {uid, emotion, emojiSetType});

					if (!res || res.code !== "0") {
						showToast("ì˜¤ë¥˜", res?.message || "ëŒ“ê¸€ ì´ëª¨ì…˜ ì‹¤íŒ¨", ToastType.ERROR);
						return;
					}

					const newList = Array.isArray(res.data) ? res.data : [];
					comment.emotionList = newList;

					rerenderPanel();
					applySum();

				} catch (e) {
					console.error(e);
					showToast("ì˜¤ë¥˜", "ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜ë¡œ ëŒ“ê¸€ ì´ëª¨ì…˜ ì‹¤íŒ¨", ToastType.ERROR);
				} finally {
					btn.disabled = false;
					btn.classList.remove('opacity-60');
				}
			}


			async function bindCommentComposer(node, item, loginUserProfileUrl) {
				const wrap = node.querySelector('.commentWrap');
				const meImg = node.querySelector('.meImg');
				const input = node.querySelector('.commentInput');
				const btn = node.querySelector('.btnSaveComment');
				const icon = node.querySelector('.iconSaveComment');

				if (!wrap || !input || !btn || !icon) return;

				if (meImg && loginUserProfileUrl) meImg.src = loginUserProfileUrl;
				icon.innerHTML = svgSaveComment();

				autoGrowTextarea(input);

				btn.addEventListener('click', async (e) => {
					e.stopPropagation();

					const content = (input.value || '').trim();
					if (!content) {
						showToast?.("ëŒ“ê¸€", "ëŒ“ê¸€ì„ ì…ë ¥í•´ ì£¼ì„¸ìš”.", ToastType?.INFO ?? "info", 1200);
						return;
					}

					btn.disabled = true;
					btn.classList.add('opacity-60');

					try {
						const url = /*[[@{/Fragment/SaveComment.json}]]*/ '/Fragment/SaveComment.json';
						const res = await apiPost(url, {
							uid: item.uid,
							content,
							emojiSetType: item.topic?.emojiSetType
						});

						if (!res || res.code !== "0" || !res.data) {
							showToast("ì˜¤ë¥˜", res?.message || "ëŒ“ê¸€ ì €ì¥ ì‹¤íŒ¨", ToastType.ERROR);
							return;
						}

						// ì„±ê³µ: ê°€ì¥ ìœ„ì— ì¶”ê°€
						const listEl = node.querySelector('.commentList');
						if (listEl) {
							listEl.prepend(renderCommentItem(res.data, item.topic?.emojiSetType));
						}

						input.value = '';
						input.style.height = 'auto';

					} catch (err) {
						console.error(e);
						showToast("ì˜¤ë¥˜", "ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜ë¡œ ëŒ“ê¸€ ì €ì¥ ì‹¤íŒ¨", ToastType.ERROR);
					} finally {
						btn.disabled = false;
						btn.classList.remove('opacity-60');
					}
				});
			}

			async function contentLoad() {
				if (loading || done) return;
				loading = true;
				hideState();

				const sendObj = /*[[${param}]]*/ {};
				sendObj.pageNo = pageNo;

				try {
					const url = /*[[@{/Fragment/Fragments.json}]]*/ "/Fragment/Fragments.json";
					const res = await apiGetWithParam(url, sendObj);

					if (!res || res.code !== "0") {
						showState("err", (res && res.message) ? res.message : "ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.");
						return;
					}

					const list = res.data;

					if (pageNo === 1) {
						const header = document.getElementById("headerTitle");
						if (header && res.title) {
							header.textContent = res.title;
						}
					}

					// ë” ì´ìƒ ë°ì´í„° ì—†ìŒ
					if (!list || list.length === 0) {
						done = true;
						// ë§ˆì§€ë§‰ì„ì„ ì‚´ì§ë§Œ í‘œì‹œ(ì›í•˜ë©´ ì œê±°)
						// showState("info", "ë§ˆì§€ë§‰ í•­ëª©ì…ë‹ˆë‹¤.");
						return;
					}

					list.forEach((item) => {
						elList.appendChild(createCard(item));
					});

					pageNo += 1;

				} catch (e) {
					console.error(e);
					showState("err", "ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜ë¡œ ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.");
				} finally {
					loading = false;
				}
			}

			function getScrollContainer() {
			  // LayoutBase ê¸°ì¤€ ì‹¤ì œ ìŠ¤í¬ë¡¤ ì»¨í…Œì´ë„ˆëŠ” main(overflow-y-auto)
			  return document.querySelector("main") || window;
			}

			function bindAutoLoadOnScrollBottom() {
			  const sentinel = document.getElementById("pageSentinel");
			  if (!sentinel) return;

			  const scroller = getScrollContainer();

			  // 1) IntersectionObserver ìš°ì„  ì ìš© (ê°€ì¥ ì•ˆì •ì )
			  if ("IntersectionObserver" in window && scroller !== window) {
			    const io = new IntersectionObserver(
			      (entries) => {
			        const e = entries[0];
			        if (e && e.isIntersecting) contentLoad();
			      },
			      {
			        root: scroller,          // â˜… main ìŠ¤í¬ë¡¤ì„ ê¸°ì¤€ìœ¼ë¡œ ê´€ì°°
			        rootMargin: "250px 0px", // ë°”ë‹¥ 250px ì „ì— ë¯¸ë¦¬ ë¡œë”©
			        threshold: 0.01
			      }
			    );
			    io.observe(sentinel);
			    return;
			  }

			  // 2) fallback: scroll ì´ë²¤íŠ¸ (rootê°€ windowì¸ ê²½ìš° í¬í•¨)
			  const target = (scroller === window) ? window : scroller;
			  target.addEventListener("scroll", () => {
			    const el = (scroller === window) ? document.documentElement : scroller;

			    const scrollTop = (scroller === window) ? (window.scrollY || el.scrollTop || 0) : el.scrollTop;
			    const clientH   = (scroller === window) ? window.innerHeight : el.clientHeight;
			    const scrollH   = el.scrollHeight;

			    // í•˜ë‹¨ 200px ê·¼ì²˜ë©´ ë‹¤ìŒ í˜ì´ì§€ ë¡œë”©
			    if (scrollTop + clientH >= scrollH - 200) {
			      contentLoad();
			    }
			  }, { passive: true });
			}

			async function init() {
			  await contentLoad();             // 1í˜ì´ì§€
			  bindAutoLoadOnScrollBottom();    // â˜… í•˜ë‹¨ì—ì„œ ë‹¤ìŒ í˜ì´ì§€ ë¡œë”©
			}

			window.addEventListener("DOMContentLoaded", init);

			window.headerSearch = function (keyword) {

				if (!keyword || keyword.trim() === "") {
					return;
				}

				// Mosaic ê²€ìƒ‰ ì²˜ë¦¬
				const url = /*[[@{/Fragment/index.html}]]*/ "/Mosaic/index.html";
				location.replace(url + "?keyword=" + encodeURIComponent(keyword));
			}
			// header buttons
			window.functionLeft = function () {
				location.replace(/*[[@{/}]]*/ '/');
			}

			window.functionRight = function () {
				location.href = /*[[@{/Fragment/Tessera.html}]]*/ "/Fragment/Tessera.html";
			}
		})();
	</script>
</th:block>

</html>