package com.utime.memoBom.common.schemasync;

import java.sql.Connection;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;

import javax.sql.DataSource;

public class SchemaSynchronizer {

	private final DataSource dataSource;
	private final H2SchemaIntrospector introspector;
	private final SchemaSyncProperties props;

	public SchemaSynchronizer(DataSource dataSource, SchemaSyncProperties props) {
		this.dataSource = dataSource;
		this.introspector = new H2SchemaIntrospector(dataSource);
		this.props = props;
	}

	public void syncAll(Map<String, String> tableToDdl) {
		for (var e : tableToDdl.entrySet()) {
//            String table = e.getKey().toUpperCase(Locale.ROOT);
			String ddl = e.getValue();

			CreateTableParser.TableSpec spec = CreateTableParser.parse(ddl);
			syncOne(spec);
		}
	}

	public void syncOne(CreateTableParser.TableSpec desired) {

		final String table = desired.tableName().toUpperCase(Locale.ROOT);

		final Map<String, H2SchemaIntrospector.ExistingColumn> existing = introspector.loadColumns(table);
		final List<String> alters = new ArrayList<>();

		// 1) 없으면 ADD COLUMN
		for (ColumnSpec c : desired.columns().values()) {
			if (!existing.containsKey(c.name())) {
				alters.add(buildAddColumn(table, c));
			}
		}

		// 2) 있으면 타입/nullable/default 비교 후 안전 범위 내 수정
		for (ColumnSpec desiredCol : desired.columns().values()) {
			var ex = existing.get(desiredCol.name());
			if (ex == null)
				continue;

			// 타입 변경: VARCHAR 길이 확장 정도만 안전하게 허용(기본)
			Optional<String> typeAlter = maybeAlterType(table, desiredCol, ex);
			typeAlter.ifPresent(alters::add);

			// NULL 허용/비허용
			Optional<String> nullAlter = maybeAlterNullability(table, desiredCol, ex);
			nullAlter.ifPresent(alters::add);

			// DEFAULT
			Optional<String> defAlter = maybeAlterDefault(table, desiredCol, ex);
			defAlter.ifPresent(alters::add);
		}

		// 3) 컬럼 삭제(옵션)
		if (props.isAllowDropColumn()) {
			Set<String> desiredNames = desired.columns().keySet();
			for (String exCol : existing.keySet()) {
				if (!desiredNames.contains(exCol)) {
					alters.add("ALTER TABLE " + table + " DROP COLUMN " + exCol);
				}
			}
		}

		executeAlters(alters);
	}

	private String buildAddColumn(String table, ColumnSpec c) {
		StringBuilder sb = new StringBuilder();
		sb.append("ALTER TABLE ").append(table).append(" ADD COLUMN ").append(c.name()).append(" ");
		sb.append(c.rawType());

		if (c.identity()) {
			sb.append(" GENERATED BY DEFAULT AS IDENTITY");
		}
		if (c.defaultExpr() != null) {
			sb.append(" DEFAULT ").append(c.defaultExpr());
		}
		if (c.notNull()) {
			sb.append(" NOT NULL");
		}
		return sb.toString();
	}

	private String normalizeDesiredType(String raw) {
		if (raw == null)
			return null;
		String t = raw.toUpperCase(Locale.ROOT).trim();

		// H2에서 CLOB/BLOB로 보이게 맞춤
		if (t.contains("CHARACTER LARGE OBJECT"))
			return "CLOB";
		if (t.contains("BINARY LARGE OBJECT"))
			return "BLOB";
		if (t.equals("TEXT"))
			return "CLOB";

		// VARCHAR / CHARACTER VARYING 동치
		if (t.startsWith("CHARACTER VARYING")) {
			// 혹시 원하는 DDL에 CHARACTER VARYING(32) 형태가 있으면 VARCHAR로 통일
			int s = t.indexOf('(');
			int e = t.indexOf(')');
			if (s > 0 && e > s)
				return "VARCHAR(" + t.substring(s + 1, e).trim() + ")";
			return "VARCHAR";
		}
		if (t.startsWith("VARCHAR"))
			return t;

		// CHAR / CHARACTER 동치
		if (t.startsWith("CHARACTER")) {
			int s = t.indexOf('(');
			int e = t.indexOf(')');
			if (s > 0 && e > s)
				return "CHAR(" + t.substring(s + 1, e).trim() + ")";
			return "CHAR";
		}
		if (t.startsWith("CHAR("))
			return t;

		// 기본은 그대로
		return t;
	}

	private Optional<String> maybeAlterType(String table, ColumnSpec desired, H2SchemaIntrospector.ExistingColumn ex) {
		String desiredType = normalizeDesiredType(desired.rawType());
		String existingType = ex.canonicalType(); // <-- 위에서 만든 표준 타입

		if (Objects.equals(desiredType, existingType))
			return Optional.empty();

		// 안전한 확장만 허용: VARCHAR/CHAR 길이 늘리기
		if (desiredType.startsWith("VARCHAR(") && existingType != null && existingType.startsWith("VARCHAR(")) {
			long dLen = extractLen(desiredType);
			long eLen = extractLen(existingType);
			if (dLen > eLen) {
				return Optional.of(
						"ALTER TABLE " + table + " ALTER COLUMN " + desired.name() + " SET DATA TYPE " + desiredType);
			}
			if (props.isAllowTypeShrink() && dLen < eLen) {
				return Optional.of(
						"ALTER TABLE " + table + " ALTER COLUMN " + desired.name() + " SET DATA TYPE " + desiredType);
			}
			return Optional.empty();
		}

		if (desiredType.startsWith("CHAR(") && existingType != null && existingType.startsWith("CHAR(")) {
			long dLen = extractLen(desiredType);
			long eLen = extractLen(existingType);
			if (dLen > eLen) {
				return Optional.of(
						"ALTER TABLE " + table + " ALTER COLUMN " + desired.name() + " SET DATA TYPE " + desiredType);
			}
			if (props.isAllowTypeShrink() && dLen < eLen) {
				return Optional.of(
						"ALTER TABLE " + table + " ALTER COLUMN " + desired.name() + " SET DATA TYPE " + desiredType);
			}
			return Optional.empty();
		}

		// CLOB/BLOB처럼 의미가 큰 타입은 기본은 건드리지 않음(데이터 위험)
		// 필요하면 옵션으로 허용하도록 분기 추가 가능
		return Optional.empty();
	}

	private long extractLen(String type) {
		int s = type.indexOf('(');
		int e = type.indexOf(')');
		if (s < 0 || e < 0 || e <= s)
			return -1;
		return Long.parseLong(type.substring(s + 1, e).trim());
	}

	private Optional<String> maybeAlterNullability(String table, ColumnSpec desired,
			H2SchemaIntrospector.ExistingColumn ex) {
		boolean desiredNotNull = desired.notNull();
		boolean existingNullable = ex.nullable();

		// desired NOT NULL인데 existing이 nullable이면 "강화" -> 기본 비허용(데이터 때문에 깨질 수 있음)
		if (desiredNotNull && existingNullable) {
			if (!props.isAllowTightenNullability())
				return Optional.empty();
			return Optional.of("ALTER TABLE " + table + " ALTER COLUMN " + desired.name() + " SET NOT NULL");
		}

		// desired nullable인데 existing이 NOT NULL이면 "완화" -> 일반적으로 안전
		if (!desiredNotNull && !existingNullable) {
			return Optional.of("ALTER TABLE " + table + " ALTER COLUMN " + desired.name() + " DROP NOT NULL");
		}

		return Optional.empty();
	}

	private Optional<String> maybeAlterDefault(String table, ColumnSpec desired,
			H2SchemaIntrospector.ExistingColumn ex) {
		
		String desiredDef = normalizeDefault(desired.defaultExpr());
		String existingDef = normalizeDefault(ex.defaultExpr());

		if (Objects.equals(desiredDef, existingDef))
			return Optional.empty();

		if (desiredDef == null) {
			return Optional.of("ALTER TABLE " + table + " ALTER COLUMN " + desired.name() + " DROP DEFAULT");
		}
		return Optional.of("ALTER TABLE " + table + " ALTER COLUMN " + desired.name() + " SET DEFAULT " + desiredDef);
	}

	private String normalizeDefault(String def) {
		if (def == null)
			return null;
		
		String d = def.trim();
		if (d.isEmpty())
			return null;

		// NULL은 의미없게
		if (d.equalsIgnoreCase("NULL"))
			return null;

		// RANDOM_UUID 와 RANDOM_UUID() 동치 처리
		if (d.equalsIgnoreCase("RANDOM_UUID"))
			return "RANDOM_UUID()";

		return d;
	}

	private void executeAlters(List<String> alters) {
		if (alters.isEmpty())
			return;

		if (props.isLogDdl()) {
			for (String a : alters) {
				System.out.println("[SCHEMA-SYNC] " + a);
			}
		}

		try (Connection c = dataSource.getConnection(); Statement st = c.createStatement()) {
			c.setAutoCommit(false);
			for (String a : alters) {
				st.execute(a);
			}
			c.commit();
		} catch (Exception e) {
			throw new RuntimeException("Schema sync failed. Alters=" + alters, e);
		}
	}
}
