package com.utime.memoBom.common.schemasync;

import java.sql.Connection;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;

import javax.sql.DataSource;

public class SchemaSynchronizer {

    private final DataSource dataSource;
    private final H2SchemaIntrospector introspector;
    private final SchemaSyncProperties props;

    public SchemaSynchronizer(DataSource dataSource, SchemaSyncProperties props) {
        this.dataSource = dataSource;
        this.introspector = new H2SchemaIntrospector(dataSource);
        this.props = props;
    }

    public void syncAll(Map<String, String> tableToDdl) {
        for (var e : tableToDdl.entrySet()) {
//            String table = e.getKey().toUpperCase(Locale.ROOT);
            String ddl = e.getValue();

            CreateTableParser.TableSpec spec = CreateTableParser.parse(ddl);
            syncOne(spec);
        }
    }

    public void syncOne(CreateTableParser.TableSpec desired) {
        String table = desired.tableName().toUpperCase(Locale.ROOT);

        Map<String, H2SchemaIntrospector.ExistingColumn> existing = introspector.loadColumns(table);
        List<String> alters = new ArrayList<>();

        // 1) 없으면 ADD COLUMN
        for (ColumnSpec c : desired.columns().values()) {
            if (!existing.containsKey(c.name())) {
                alters.add(buildAddColumn(table, c));
            }
        }

        // 2) 있으면 타입/nullable/default 비교 후 안전 범위 내 수정
        for (ColumnSpec desiredCol : desired.columns().values()) {
            var ex = existing.get(desiredCol.name());
            if (ex == null) continue;

            // 타입 변경: VARCHAR 길이 확장 정도만 안전하게 허용(기본)
            Optional<String> typeAlter = maybeAlterType(table, desiredCol, ex);
            typeAlter.ifPresent(alters::add);

            // NULL 허용/비허용
            Optional<String> nullAlter = maybeAlterNullability(table, desiredCol, ex);
            nullAlter.ifPresent(alters::add);

            // DEFAULT
            Optional<String> defAlter = maybeAlterDefault(table, desiredCol, ex);
            defAlter.ifPresent(alters::add);
        }

        // 3) 컬럼 삭제(옵션)
        if (props.isAllowDropColumn()) {
            Set<String> desiredNames = desired.columns().keySet();
            for (String exCol : existing.keySet()) {
                if (!desiredNames.contains(exCol)) {
                    alters.add("ALTER TABLE " + table + " DROP COLUMN " + exCol);
                }
            }
        }

        executeAlters(alters);
    }

    private String buildAddColumn(String table, ColumnSpec c) {
        StringBuilder sb = new StringBuilder();
        sb.append("ALTER TABLE ").append(table).append(" ADD COLUMN ").append(c.name()).append(" ");
        sb.append(c.rawType());

        if (c.identity()) {
            sb.append(" GENERATED BY DEFAULT AS IDENTITY");
        }
        if (c.defaultExpr() != null) {
            sb.append(" DEFAULT ").append(c.defaultExpr());
        }
        if (c.notNull()) {
            sb.append(" NOT NULL");
        }
        return sb.toString();
    }

    private Optional<String> maybeAlterType(String table, ColumnSpec desired, H2SchemaIntrospector.ExistingColumn ex) {
        // desired.rawType 예: VARCHAR(128)
        // ex.typeName 예: VARCHAR  / ex.charLen: 64
        String d = desired.rawType().toUpperCase(Locale.ROOT);

        if (d.startsWith("VARCHAR(") || d.startsWith("CHAR(")) {
            long desiredLen = extractLen(d);
            if (ex.charLen() == null) return Optional.empty();

            long existingLen = ex.charLen();
            if (desiredLen == existingLen) return Optional.empty();

            if (desiredLen > existingLen) {
                return Optional.of("ALTER TABLE " + table + " ALTER COLUMN " + desired.name() + " SET DATA TYPE " + desired.rawType());
            }

            // 축소는 위험(기본 비허용)
            if (props.isAllowTypeShrink()) {
                return Optional.of("ALTER TABLE " + table + " ALTER COLUMN " + desired.name() + " SET DATA TYPE " + desired.rawType());
            }
            return Optional.empty();
        }

        // 타입명이 다르면 변경할지? (기본은 건드리지 않음)
        // 필요하면 여기 확장: BIGINT<->INT 같은 위험도를 분류
        return Optional.empty();
    }

    private long extractLen(String type) {
        int s = type.indexOf('(');
        int e = type.indexOf(')');
        if (s < 0 || e < 0 || e <= s) return -1;
        return Long.parseLong(type.substring(s + 1, e).trim());
    }

    private Optional<String> maybeAlterNullability(String table, ColumnSpec desired, H2SchemaIntrospector.ExistingColumn ex) {
        boolean desiredNotNull = desired.notNull();
        boolean existingNullable = ex.nullable();

        // desired NOT NULL인데 existing이 nullable이면 "강화" -> 기본 비허용(데이터 때문에 깨질 수 있음)
        if (desiredNotNull && existingNullable) {
            if (!props.isAllowTightenNullability()) return Optional.empty();
            return Optional.of("ALTER TABLE " + table + " ALTER COLUMN " + desired.name() + " SET NOT NULL");
        }

        // desired nullable인데 existing이 NOT NULL이면 "완화" -> 일반적으로 안전
        if (!desiredNotNull && !existingNullable) {
            return Optional.of("ALTER TABLE " + table + " ALTER COLUMN " + desired.name() + " DROP NOT NULL");
        }

        return Optional.empty();
    }

    private Optional<String> maybeAlterDefault(String table, ColumnSpec desired, H2SchemaIntrospector.ExistingColumn ex) {
        String desiredDef = normalizeDefault(desired.defaultExpr());
        String existingDef = normalizeDefault(ex.defaultExpr());

        if (Objects.equals(desiredDef, existingDef)) return Optional.empty();

        if (desiredDef == null) {
            return Optional.of("ALTER TABLE " + table + " ALTER COLUMN " + desired.name() + " DROP DEFAULT");
        }
        return Optional.of("ALTER TABLE " + table + " ALTER COLUMN " + desired.name() + " SET DEFAULT " + desiredDef);
    }

    private String normalizeDefault(String def) {
        if (def == null) return null;
        String d = def.trim();
        // H2는 기본값 표현이 괄호/캐스팅 등으로 저장될 수 있어서 여기서 더 정교하게 맞추고 싶으면 확장
        return d.isEmpty() ? null : d;
    }

    private void executeAlters(List<String> alters) {
        if (alters.isEmpty()) return;

        if (props.isLogDdl()) {
            for (String a : alters) {
                System.out.println("[SCHEMA-SYNC] " + a);
            }
        }

        try (Connection c = dataSource.getConnection();
             Statement st = c.createStatement()) {
            c.setAutoCommit(false);
            for (String a : alters) {
                st.execute(a);
            }
            c.commit();
        } catch (Exception e) {
            throw new RuntimeException("Schema sync failed. Alters=" + alters, e);
        }
    }
}
